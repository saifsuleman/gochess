package engine

import (
	"gochess/core"
)

const (
	MateScore     = 30000
	MateThreshold = MateScore - 1000
)

func (e *Engine) negamax(depth int, alpha, beta, rootDepth int) int {
	e.NodesSearched++

	if e.NodesSearched%2048 == 0 && e.TimeUp() {
		e.Aborted = true
		return 0
	}

	originalAlpha := alpha
	key := e.Board.ComputeZobristHash()

	var ttMove core.Move
	if ok, score, _, m := e.TT.ProbeCut(key, depth, alpha, beta, e.Board.Ply); ok {
		return score
	} else {
		ttMove = m
	}

	if depth <= 0 {
		return e.quiscence(alpha, beta, rootDepth)
	}

	// TODO: keep an eye on this, I've found sometimes it makes the engine worse
	// i don't trust you
	isNullWindow := beta-alpha == 1
	nmpMask := e.Board.AllPieces
	nmpMask ^= e.Board.PieceBitboards[0][core.PieceTypeKing-1] | e.Board.PieceBitboards[1][core.PieceTypeKing-1]
	nmpMask ^= e.Board.PieceBitboards[0][core.PieceTypePawn-1] | e.Board.PieceBitboards[1][core.PieceTypePawn-1]
	if isNullWindow && depth >= 3 && nmpMask != 0 && !e.Board.InCheck(e.Board.WhiteToMove) && e.Evaluate() >= beta {
		enPassant := e.Board.EnPassantTarget
		e.Board.EnPassantTarget = 64
		e.Board.WhiteToMove = !e.Board.WhiteToMove

		nullScore := -e.negamax(depth-3, -beta, -beta+1, rootDepth) // reduction R=2

		e.Board.WhiteToMove = !e.Board.WhiteToMove
		e.Board.EnPassantTarget = enPassant

		if nullScore >= beta {
			depth -= 4
			if depth <= 0 {
				return e.quiscence(alpha, beta, rootDepth)
			}
		}
	}

	board := e.Board
	moves := board.GenerateLegalMoves()
	if len(moves) == 0 {
		if board.InCheck(board.WhiteToMove) {
			return -MateScore + board.Ply // checkmate
		}
		return 0 // stalemate
	}

	var bestMove core.Move
	var bestScore int = -100000

	if ttMove != (core.Move{}) {
		board.Push(&ttMove)
		score := -e.negamax(depth-1, -beta, -alpha, rootDepth)
		board.Pop()

		bestScore = score
		bestMove = ttMove
		if score > alpha {
			alpha = score
		}

		if alpha >= beta {
			e.TT.Store(key, depth, bestScore, FlagLower, bestMove)
			return bestScore
		}
	}

	e.OrderMoves(moves, rootDepth)

	firstMove := true
	for i, move := range moves {
		if move == ttMove {
			continue
		}

		isCapture := (move.To == board.EnPassantTarget) || ((1<<move.To)&board.AllPieces) != 0
		board.Push(&move)
		searchDepth := depth - 1

		// LMR
		enemyInCheck := board.InCheck(board.WhiteToMove)
		if depth >= 3 && !isCapture && !enemyInCheck && i > 3 {
			searchDepth = depth - 2
		}

		var score int
		if firstMove {
			score = -e.negamax(searchDepth, -beta, -alpha, rootDepth)
			firstMove = false
		} else {
			score = -e.negamax(searchDepth, -alpha-1, -alpha, rootDepth)
			if score > alpha && score < beta {
				score = -e.negamax(searchDepth, -beta, -alpha, rootDepth)
			}
		}

		board.Pop()

		if score > bestScore {
			bestScore = score
			bestMove = move
		}
		if bestScore > alpha {
			alpha = bestScore
		}
		if alpha >= beta {
			isCapture := move.To == board.EnPassantTarget || ((1<<move.To)&board.AllPieces) != 0
			if !isCapture {
				e.addKillerMove(move, depth)
				e.HistoryTable[move.From][move.To] += depth * depth
			}
			break
		}
	}

	// Store result in TT
	var bound Bound
	switch {
	case bestScore <= originalAlpha:
		bound = FlagUpper
	case bestScore >= beta:
		bound = FlagLower
	default:
		bound = FlagExact
	}

	e.TT.Store(key, depth, bestScore, bound, bestMove)

	return bestScore
}
package engine

import (
	"gochess/core"
	"slices"
)

func (e *Engine) MVVLVA(move core.Move) (score int) {
	score = 0

	switch move.Promotion {
	case core.PieceTypeQueen:
		score += 900
	case core.PieceTypeRook:
		score += 500
	case core.PieceTypeBishop:
		score += 300
	case core.PieceTypeKnight:
		score += 350 // knight promotions are badass
	}

	attacker := e.Board.Pieces[move.From]
	victim := e.Board.Pieces[move.To]

	if (attacker&core.PieceTypeMask) == core.PieceTypePawn && move.To == e.Board.EnPassantTarget {
		victim = core.PieceTypePawn | ^(attacker & core.PieceColorMask)
	}

	if ((attacker & core.PieceTypeMask) == core.PieceTypePawn) && (move.To == move.From+16 || move.To == move.From-16) {
		score += 50
	}

	if victim != core.PieceNone {
		score += 100 + 10*e.PieceValue(victim) - e.PieceValue(attacker)
	}

	return score
}

func (e *Engine) OrderMovesQ(moves []core.Move, depth int) {
	slices.SortStableFunc(moves, func(a, b core.Move) int {
		scoreA := e.SEE(a) + e.killerHistoryScore(a, depth)
		scoreB := e.SEE(b) + e.killerHistoryScore(b, depth)
		return scoreB - scoreA // Descending order
	})
}

func (e *Engine) OrderMoves(moves []core.Move, depth int) {
	slices.SortStableFunc(moves, func(a, b core.Move) int {
		scoreA := e.MVVLVA(a) + e.killerHistoryScore(a, depth)
		scoreB := e.MVVLVA(b) + e.killerHistoryScore(b, depth)
		return scoreB - scoreA // Descending order
	})
}

func (e *Engine) killerHistoryScore(move core.Move, depth int) int {
	if move == e.KillerMoves[depth][0] {
		return 100_000
	}

	if move == e.KillerMoves[depth][1] {
		return 80_000
	}

	isCapture := (move.To == e.Board.EnPassantTarget) || ((1<<move.To)&e.Board.AllPieces) != 0
	if !isCapture {
		return e.HistoryTable[move.From][move.To]
	}

	return 0
}

func (e *Engine) SEE(move core.Move) int {
	from := move.From
	to := move.To

	board := e.Board
	attackerIsWhite := (board.Pieces[from] & core.PieceColorMask) == core.PieceColorWhite
	attackers := make([]int, 0)
	defenders := make([]int, 0)
	attackersBB := board.GetAttackingBitboard(to, attackerIsWhite)
	defendersBB := board.GetAttackingBitboard(to, !attackerIsWhite)
	for sq := range 64 {
		if (attackersBB>>sq)&1 != 0 {
			attackers = append(attackers, sq)
		}
		if (defendersBB>>sq)&1 != 0 {
			defenders = append(defenders, sq)
		}
	}

	victim := board.Pieces[to]
	gains := []int{e.PieceValue(victim)}
	turn := attackerIsWhite

	for {
		var next int
		var nextVal int
		if turn == attackerIsWhite {
			if len(attackers) == 0 {
				break
			}
			next = e.leastValuablePiece(board, attackers)
			nextVal = e.PieceValue(board.Pieces[next])
			attackers = removeSquare(attackers, next)
		} else {
			if len(defenders) == 0 {
				break
			}
			next = e.leastValuablePiece(board, defenders)
			nextVal = e.PieceValue(board.Pieces[next])
			defenders = removeSquare(defenders, next)
		}

		lastGain := gains[len(gains)-1]
		gains = append(gains, nextVal-lastGain)
		turn = !turn
	}

	for i := len(gains) - 2; i >= 0; i-- {
		gains[i] = max(-gains[i+1], gains[i])
	}

	return gains[0]
}

func (e *Engine) leastValuablePiece(board *core.Board, squares []int) int {
	least := squares[0]
	val := e.PieceValue(board.Pieces[least])
	for _, sq := range squares[1:] {
		v := e.PieceValue(board.Pieces[sq])
		if v < val {
			val = v
			least = sq
		}
	}
	return least
}

func removeSquare(slice []int, sq int) []int {
	for i, s := range slice {
		if s == sq {
			return append(slice[:i], slice[i+1:]...)
		}
	}
	return slice
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

package engine

var pawnPST = PST{
	0, 0, 0, 0, 0, 0, 0, 0,
	50, 50, 50, 50, 50, 50, 50, 50,
	10, 10, 20, 30, 30, 20, 10, 10,
	5, 5, 10, 25, 25, 10, 5, 5,
	0, 0, 0, 20, 20, 0, 0, 0,
	5, -5, -10, 0, 0, -10, -5, 5,
	5, 10, 10, -20, -20, 10, 10, 5,
	0, 0, 0, 0, 0, 0, 0, 0,
}

var knightPST = PST{
	-50, -40, -30, -30, -30, -30, -40, -50,
	-40, -20, 0, 0, 0, 0, -20, -40,
	-30, 0, 10, 15, 15, 10, 0, -30,
	-30, 5, 15, 20, 20, 15, 5, -30,
	-30, 0, 15, 20, 20, 15, 0, -30,
	-30, 5, 10, 15, 15, 10, 5, -30,
	-40, -20, 0, 5, 5, 0, -20, -40,
	-50, -40, -30, -30, -30, -30, -40, -50,
}

var bishopPST = PST{
	-20, -10, -10, -10, -10, -10, -10, -20,
	-10, 0, 0, 0, 0, 0, 0, -10,
	-10, 0, 5, 10, 10, 5, 0, -10,
	-10, 5, 5, 10, 10, 5, 5, -10,
	-10, 0, 10, 10, 10, 10, 0, -10,
	-10, 10, 10, 10, 10, 10, 10, -10,
	-10, 5, 0, 0, 0, 0, 5, -10,
	-20, -10, -10, -10, -10, -10, -10, -20,
}

var rookPST = PST{
	0, 0, 0, 0, 0, 0, 0, 0,
	5, 10, 10, 10, 10, 10, 10, 5,
	-5, 0, 0, 0, 0, 0, 0, -5,
	-5, 0, 0, 0, 0, 0, 0, -5,
	-5, 0, 0, 0, 0, 0, 0, -5,
	-5, 0, 0, 0, 0, 0, 0, -5,
	-5, 0, 0, 0, 0, 0, 0, -5,
	0, 0, 0, 5, 5, 0, 0, 0,
}

var queenPST = PST{
	-20, -10, -10, -5, -5, -10, -10, -20,
	-10, 0, 0, 0, 0, 0, 0, -10,
	-10, 0, 5, 5, 5, 5, 0, -10,
	-5, 0, 5, 5, 5, 5, 0, -5,
	0, 0, 5, 5, 5, 5, 0, -5,
	-10, 5, 5, 5, 5, 5, 0, -10,
	-10, 0, 5, 0, 0, 0, 0, -10,
	-20, -10, -10, -5, -5, -10, -10, -20,
}

var kingPSTMiddlegame = [64]int{
	-30, -40, -40, -50, -50, -40, -40, -30,
	-30, -40, -40, -50, -50, -40, -40, -30,
	-30, -40, -40, -50, -50, -40, -40, -30,
	-30, -40, -40, -50, -50, -40, -40, -30,
	-20, -30, -30, -40, -40, -30, -30, -20,
	-10, -20, -20, -20, -20, -20, -20, -10,
	20, 20, 0, 0, 0, 0, 20, 20,
	20, 30, 10, 0, 0, 10, 30, 20,
}

var kingPSTEndgame = [64]int{
	-50, -40, -30, -20, -20, -30, -40, -50,
	-30, -20, -10, 0, 0, -10, -20, -30,
	-30, -10, 20, 30, 30, 20, -10, -30,
	-30, -10, 30, 40, 40, 30, -10, -30,
	-30, -10, 30, 40, 40, 30, -10, -30,
	-30, -10, 20, 30, 30, 20, -10, -30,
	-30, -30, 0, 0, 0, 0, -30, -30,
	-50, -30, -30, -30, -30, -30, -30, -50,
}
package engine

func (e *Engine) quiscence(alpha, beta, rootDepth int) (score int) {
	e.NodesSearched++
	standPat := e.Evaluate()

	if standPat >= beta {
		return beta
	}

	if standPat > alpha {
		alpha = standPat
	}

	moves := e.Board.GenerateLegalCaptures()
	e.OrderMovesQ(moves, rootDepth)
	for _, move := range moves {
		e.Board.Push(&move)
		score := -e.quiscence(-beta, -alpha, rootDepth)
		e.Board.Pop()

		if score >= beta {
			return score
		}

		if score > alpha {
			alpha = score
		}
	}

	return alpha
}

package engine

import (
	"gochess/core"
)

const (
	PhaseOpening Phase = iota
	PhaseMiddlegame
	PhaseEndgame
)

var phaseWeights = map[uint8]int{
	core.PieceTypeKnight: 1,
	core.PieceTypeBishop: 1,
	core.PieceTypeRook:   2,
	core.PieceTypeQueen:  4,
}

const maxPhaseScore = 24

type Phase int
type PST [64]int

func (e *Engine) Evaluate() int {
	score := 0
	mask := e.Board.AllPieces

	phase := determinePhase(e.Board)

	for mask != 0 {
		lsb := core.Position(mask.PopLSB())
		piece := e.Board.Pieces[lsb]
		value := e.PieceValue(piece)
		value += pstValue(piece, lsb, phase)
		if piece.Color() == core.PieceColorWhite {
			score += value
		} else {
			score -= value
		}
	}

	if e.Board.WhiteToMove {
		return score
	} else {
		return -score
	}
}

func determinePhase(b *core.Board) Phase {
	score := 0
	for sq := range 64 {
		piece := b.Pieces[sq]
		pt := piece.Type()
		if w, ok := phaseWeights[pt]; ok {
			score += w
		}
	}
	switch {
	case score > maxPhaseScore*2/3:
		return PhaseOpening
	case score > maxPhaseScore/3:
		return PhaseMiddlegame
	default:
		return PhaseEndgame
	}
}

func pstValue(piece core.Piece, sq core.Position, phase Phase) int {
	var normalized core.Position

	color := piece.Color()
	type_ := piece.Type()

	if color == core.PieceColorWhite {
		normalized = sq
	} else {
		rank := sq >> 3
		file := sq & 7
		normalized = (7-rank)<<3 | file
	}

	switch type_ {
	case core.PieceTypePawn:
		return pawnPST[normalized]
	case core.PieceTypeKnight:
		return knightPST[normalized]
	case core.PieceTypeBishop:
		return bishopPST[normalized]
	case core.PieceTypeRook:
		return rookPST[normalized]
	case core.PieceTypeQueen:
		return queenPST[normalized]
	case core.PieceTypeKing:
		if phase == PhaseEndgame {
			return kingPSTEndgame[normalized]
		} else {
			return kingPSTMiddlegame[normalized]
		}
	}

	return 0 // i mean this shouldn't happen
}

func (e *Engine) PieceValue(piece core.Piece) int {
	type_ := piece.Type()
	switch type_ {
	case core.PieceTypeNone:
		return 0
	case core.PieceTypePawn:
		return 100
	case core.PieceTypeKnight:
		return 320
	case core.PieceTypeBishop:
		return 330
	case core.PieceTypeRook:
		return 500
	case core.PieceTypeQueen:
		return 900
	case core.PieceTypeKing:
		return 20000
	default:
		return 0
	}
}
package engine

import (
	"fmt"
	"gochess/core"
	"math"
	"time"
)

/*
TODO:
- Implement iterative deepening [DONE]
- Implement move ordering [DONE]
- Implement transposition tables [DONE]
- Implement quiescence search [DONE]
- Implement null move pruning [DONE]
- Implement late move reductions (LMR) [DONE]
- Implement time management [DONE]
- Basic material exchange evaluation [DONE]
- Implement piece-square-tables [DONE]
- Implement killer moves [DONE]
- Implement SEE on quiescence search [DONE]

- Implement passed pawn evaluation
- Implement king safety evaluation
- Implement mobility evaluation
- Implement outposts evaluation
- Repetition penalization

- Implement UCI protocol
- Implement opening book
- Implement endgame tablebases
- Implement dynamic time budget allocation
- Build unit tests
- Measure ELO impact of each feature in isolation
- Implement multi-threading
*/

const maxDepth = 8

type Engine struct {
	Board         *core.Board
	TT            *TranspositionalTable
	Deadline      time.Time
	NodesSearched uint64
	Aborted       bool
	KillerMoves   [maxDepth + 1][2]core.Move
	HistoryTable  [64][64]int
}

func (e *Engine) TimeUp() bool {
	return time.Now().After(e.Deadline)
}

func NewEngine(board *core.Board) *Engine {
	return &Engine{Board: board, TT: NewTranspositionalTable(256)}
}

func (e *Engine) FindBestMove(timeBudget time.Duration, nmp bool) *core.Move {
	start := time.Now()

	e.Deadline = start.Add(timeBudget)
	e.NodesSearched = 0

	moves := e.Board.GenerateLegalMoves()
	if len(moves) == 0 {
		return nil
	} else if len(moves) == 1 {
		return &moves[0] // I mean, no point in searching if there's only one move
	}

	e.OrderMoves(moves, 0)

	var bestMove core.Move = moves[0]
	var bestValue int
	depthReached := 0

	for depth := 1; depth <= maxDepth; depth++ {
		if e.TimeUp() {
			break
		}

		currentBestMove := moves[0]
		currentBestValue := math.MinInt
		completedSearch := true

		for _, move := range moves {
			e.Board.Push(&move)
			e.Aborted = false
			moveValue := -e.negamax(depth-1, math.MinInt, math.MaxInt, depth)
			e.Board.Pop()

			if e.Aborted {
				completedSearch = false
				break // Do not use a partially searched path
			}

			if moveValue > currentBestValue {
				currentBestValue = moveValue
				currentBestMove = move
			}

			if currentBestValue >= MateThreshold {
				break
			}
		}

		if !completedSearch {
			break
		}

		bestMove = currentBestMove
		bestValue = currentBestValue
		depthReached = depth

		for i, m := range moves {
			if m == bestMove {
				moves[0], moves[i] = moves[i], moves[0]
				break
			}
		}
	}

	elapsed := time.Since(start)
	fmt.Printf("Best move: %v, depth: %d, nodes searched: %d at depth %d, Time taken: %s\n", bestMove, bestValue, e.NodesSearched, depthReached, elapsed)

	return &bestMove
}

func (e *Engine) addKillerMove(move core.Move, depth int) {
	if e.KillerMoves[depth][0] != move {
		e.KillerMoves[depth][1] = e.KillerMoves[depth][0]
		e.KillerMoves[depth][0] = move
	}
}
package engine

import "gochess/core"

type Bound uint8

const (
	FlagUpper Bound = iota
	FlagLower
	FlagExact
)

type TTEntry struct {
	PartialKey uint16
	Move       core.Move
	Score      int16
	depth      int8
	bound      Bound
	gen        uint8
}

type TTBucket struct {
	Entries [4]TTEntry
}

type TranspositionalTable struct {
	Buckets []TTBucket
	Mask    uint64
	Gen     uint8
}

func NewTranspositionalTable(sizeMB int) *TranspositionalTable {
	numBuckets := (sizeMB * 1024 * 1024) / (4 * 16)
	if numBuckets <= 0 {
		numBuckets = 1
	}
	return &TranspositionalTable{
		Buckets: make([]TTBucket, numBuckets),
		Mask:    uint64(numBuckets - 1),
	}
}

func (tt *TranspositionalTable) Clear() {
	for i := range tt.Buckets {
		var zero TTBucket
		tt.Buckets[i] = zero
	}

	tt.Gen = 1
}

func (tt *TranspositionalTable) NewGeneration() {
	tt.Gen++
}

func partialKey(full uint64) uint16 {
	return uint16(full >> 48) // fuck them 48 bits
}

func (tt *TranspositionalTable) index(full uint64) int {
	return int(full & tt.Mask)
}

func ToTTScore(score, ply int) int16 {
	if score >= MateThreshold {
		return int16(score + ply)
	}

	if score <= -MateThreshold {
		return int16(score - ply)
	}

	return int16(score)
}

func FromTTScore(stored int16, ply int) int {
	s := int(stored)
	if s >= MateThreshold {
		return s - ply
	}
	if s <= -MateThreshold {
		return s + ply
	}
	return s
}

func (tt *TranspositionalTable) Probe(key uint64) (bit bool, e TTEntry) {
	idx := tt.index(key)
	pk := partialKey(key)
	b := &tt.Buckets[idx]

	for i := range b.Entries {
		if b.Entries[i].PartialKey == pk {
			return true, b.Entries[i]
		}
	}

	return false, TTEntry{}
}

func (tt *TranspositionalTable) Store(key uint64, depth int, score int, bound Bound, move core.Move) {
	idx := tt.index(key)
	pk := partialKey(key)
	b := &tt.Buckets[idx]

	for i := range b.Entries {
		if b.Entries[i].PartialKey == pk {
			if depth >= int(b.Entries[i].depth) || bound == FlagExact {
				b.Entries[i].Score = ToTTScore(score, 0)
				b.Entries[i].depth = int8(depth)
				b.Entries[i].bound = bound
				if move != (core.Move{}) {
					b.Entries[i].Move = move
				}
				b.Entries[i].gen = tt.Gen
			} else {
				if move != (core.Move{}) {
					b.Entries[i].Move = move
				}

				b.Entries[i].gen = tt.Gen
			}

			return
		}
	}

	victim := 0
	bestScore := 1<<31 - 1
	for i := range b.Entries {
		if b.Entries[i].PartialKey == 0 {
			victim = i
			break
		}

		penalty := int(b.Entries[i].depth)
		if b.Entries[i].gen == tt.Gen {
			penalty += 8
		}

		if penalty < bestScore {
			bestScore = penalty
			victim = i
		}
	}

	b.Entries[victim] = TTEntry{
		PartialKey: pk,
		Score:      ToTTScore(score, 0),
		depth:      int8(depth),
		bound:      bound,
		Move:       move,
		gen:        tt.Gen,
	}
}

func (tt *TranspositionalTable) ProbeCut(key uint64, depth, alpha, beta, ply int) (ok bool, score int, flag Bound, move core.Move) {
	hit, e := tt.Probe(key)
	if !hit {
		return false, 0, FlagExact, core.Move{}
	}
	s := FromTTScore(e.Score, ply)
	if int(e.depth) >= depth {
		switch e.bound {
		case FlagExact:
			return true, s, e.bound, e.Move
		case FlagLower:
			if s >= beta {
				return true, s, e.bound, e.Move
			}
		case FlagUpper:
			if s <= alpha {
				return true, s, e.bound, e.Move
			}
		}
	}

	return false, s, e.bound, e.Move
}
